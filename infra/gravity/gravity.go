package gravity

import (
	"context"
	"fmt"
	"time"

	"github.com/gravitational/robotest/infra"
	sshutils "github.com/gravitational/robotest/lib/ssh"
	"github.com/gravitational/trace"

	"golang.org/x/crypto/ssh"
)

/*
 Gravity is interface to remote gravity CLI
*/
type Gravity interface {
	Install(ctx context.Context, param InstallCmd) error
	Status(ctx context.Context) (*GravityStatus, error)
	OfflineUpdate(ctx context.Context, installerUrl string) error
	Join(ctx context.Context, peerAddr, token, role string) error
	Node() infra.Node
}

// install parameters passed to first node
type InstallCmd struct {
	// Token is required to join cluster
	Token string
	// Cluster is Optional name of the cluster. Autogenerated if not set.
	Cluster string
	// Flavor is (Optional) Application flavor. See Application Manifest for details.
	Flavor string
	// K8SConfig is (Optional) File with Kubernetes resources to create in the cluster during installation.
	K8SConfig string
	// PodNetworkCidr is (Optional) CIDR range Kubernetes will be allocating node subnets and pod IPs from. Must be a minimum of /16 so Kubernetes is able to allocate /24 to each node. Defaults to 10.244.0.0/16.
	PodNetworkCIDR string
	// ServiceCidr (Optional) CIDR range Kubernetes will be allocating service IPs from. Defaults to 10.100.0.0/16.
	ServiceCIDR string
	// DockerVolume is dedicated docker device
	DockerVolume string `validation:"required"`
}

// GravityStatus is serialized form of `gravity status` CLI.
type GravityStatus struct {
	Application string
	Cluster     string
	Status      string
	// Token is secure token which prevents rogue nodes from joining the cluster during installation.
	Token string `validation:"required"`
	// Nodes defines nodes the cluster observes
	Nodes []string
}

type gravity struct {
	node       infra.Node
	logFn      sshutils.LogFnType
	installDir string
	ssh        *ssh.Client
}

const retrySSH = time.Second * 10

// FromNode takes a provisioned and set up Node and makes Gravity control interface
func FromNode(ctx context.Context, logFn sshutils.LogFnType, node infra.Node, installDir string) (Gravity, error) {
	g := gravity{
		node:       node,
		logFn:      logFn,
		installDir: installDir,
	}

	// node might be provisioned, but SSH daemon not up just yet
	for {
		client, err := node.Client()

		if err == nil {
			g.ssh = client
			return &g, nil
		}

		logFn("error SSH %s, retry in %v", node.Addr(), retrySSH)
		select {
		case <-ctx.Done():
			return nil, trace.Wrap(err, "SSH timed out dialing %s", node.Addr())
		case <-time.After(retrySSH):
		}
	}
}

func (g *gravity) Node() infra.Node {
	return g.node
}

// Install runs gravity install with params
func (g *gravity) Install(ctx context.Context, param InstallCmd) error {
	cmd := fmt.Sprintf("%s/gravity install --advertise-addr=%s --token=%s --docker-device=%s",
		g.installDir, g.node.PrivateAddr(), "TODO_GENERATEGUID", param.DockerVolume)

	err := sshutils.Run(ctx, g.logFn, g.ssh,
		cmd, nil)
	return trace.Wrap(err, cmd)
}

func (g *gravity) Status(ctx context.Context) (*GravityStatus, error) {
	cmd := fmt.Sprintf("%s/gravity status")
	status, exit, err := sshutils.RunAndParse(ctx, g.logFn, g.ssh,
		cmd, nil, parseStatus)

	if err != nil {
		return nil, trace.Wrap(err, cmd)
	}

	if exit != 0 {
		return nil, trace.Errorf("%s returned %d", cmd, exit)
	}

	return status.(*GravityStatus), nil
}

func (g *gravity) OfflineUpdate(ctx context.Context, installerUrl string) error {
	return nil
}

func (g *gravity) Join(ctx context.Context, peerAddr, token, role string) error {
	cmd := fmt.Sprintf("%s/gravity join %s --advertise-addr=%s --token=%s --role=%s",
		g.installDir, peerAddr, g.node.PrivateAddr(), token, role)

	err := sshutils.Run(ctx, g.logFn, g.ssh,
		cmd, nil)

	return trace.Wrap(err, cmd)
}
